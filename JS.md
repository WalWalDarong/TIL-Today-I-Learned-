# TIL-Today-I-Learned-
## 헷갈리는 개념
### 함수 선언식 vs 함수 표현식
: 함수 선언식은 hoisting 되지만, 표현식은 안됨

- 표현식: 
var 함수 이름 = function () { return}

- 화살표 함수:
 전통적인 함수표현(function)의 간편한 대안. 하지만, 화살표 함수는 몇 가지 제한점이 있고 모든 상황에 사용할 수는 없음.
     // 매개변수가 하나뿐인 경우 괄호는 선택사항:
    (singleParam) => { statements }
    singleParam => { statements }

    // 매개변수가 없는 함수는 괄호가 필요:
    () => { statements }

Object의 property는 순서가 없음
출력될 때 순서 바뀌어서 나옴
Index도 없음


### object
#### dot notation VS bracket notation
: dot notation은 key를 string으로 인식, 변수(variable)로 설정한 key는 dot notation으로 사용 불가
> variable에 key 할당하는 건 bracket notation으로만 사용 가능   
> bracket 안에 변수는 ''없이, key는 '' 있이 사용

### Function
*  인수에 순서가 있으니, 그걸 해결하려면 function 안에서 object 사용
* function({key1: value1, key2: value2, key3:value3})
* Return = 반환과 동시에 "종료"

* 변수명 줄임말 쓰지 말기 코드가 복잡한데 줄임말까지 쓰면 협업하기 힘듦

### 배열
* 배열에서 뭐가 안된다고 하면 대부분 for문
* 현업에서는 for문을 거의 안 씀
* 배열 method 사용, 함수형 프로그래밍 e.g., array.filter VS array.map
* map, for일치?, 같은 걸 많이 씀
=> 배열이 어렵고 헷갈림 

* 사망 연산자? '?'
> a === 1-? //a는 10'입니다' : a는 10이 아닙니다

#### for문 VS While문
for문과 while문은 둘 다 자바스크립트에서 반복문을 구현하는 데 사용됩니다. 하지만 두 반복문의 구문과 사용 방법에는 차이가 있습니다.

for문은 초기식, 조건식, 증감식으로 구성된 반복문입니다. for문은 일반적으로 반복 횟수를 알고 있을 때 사용합니다. 초기식은 반복문이 시작되기 전에 한 번 실행되며, 조건식은 매 반복마다 평가됩니다. 조건식이 true이면, 반복문이 실행되고 증감식이 실행됩니다. 그 후, 조건식이 다시 평가됩니다. 조건식이 false이면, 반복문이 종료됩니다.

예시:
```js

for (var i = 0; i < 10; i++) {
  console.log(i);
}
```
위 예시에서 for문은 i가 0부터 시작하며, i가 10보다 작을 때까지 실행됩니다. i가 한 번 실행될 때마다, i의 값을 출력하고, i를 1씩 증가시킵니다. for문은 총 10번 반복되고, 0부터 9까지의 값을 출력합니다.

while문은 조건식으로만 구성된 반복문입니다. while문은 일반적으로 반복 횟수를 모를 때 사용합니다. 조건식이 true이면, 반복문이 실행됩니다. 반복문이 실행될 때마다, 조건식이 다시 평가됩니다. 조건식이 false이면, 반복문이 종료됩니다.

예시:
```js

var i = 0;

while (i < 10) {
  console.log(i);
  i++;
}
```
위 예시에서 while문은 i가 10보다 작을 때까지 실행됩니다. i가 한 번 실행될 때마다, i의 값을 출력하고, i를 1씩 증가시킵니다. while문은 총 10번 반복되고, 0부터 9까지의 값을 출력합니다.

따라서, for문은 일반적으로 반복 횟수를 알고 있을 때, while문은 일반적으로 반복 횟수를 모를 때 사용합니다.

### var, const, let의 차이
1. var   
 var는 ES5 이전에 사용되던 변수 선언 키워드입니다.
 함수 스코프(function scope)를 가집니다. 즉, 변수가 선언된 함수 내에서만 유효합니다.
 var로 선언된 변수는 선언하기 전에도 사용할 수 있습니다. (호이스팅(hoisting) 특성)
2. let   
 ES6에서 도입된 변수 선언 키워드입니다.
 블록 스코프(block scope)를 가집니다. 즉, 변수가 선언된 블록(중괄호 {}) 내에서만 유효합니다.
 let으로 선언된 변수는 선언하기 전에는 사용할 수 없습니다.
3. const   
 ES6에서 도입된 변수 선언 키워드입니다.
 블록 스코프(block scope)를 가집니다.
 const로 선언된 변수는 값을 변경할 수 없습니다. 상수(constant)와 같은 역할을 합니다.
 const로 선언된 객체나 배열은 값을 변경할 수 있지만, 객체나 배열 자체를 다른 객체나 배열로 재할당할 수 없습니다.
> 따라서, 변수의 값이 변하지 않는 경우 const를 사용하고, 값이 변하는 변수는 let을 사용하는 것이 좋습니다. var는 호이스팅 특성 때문에 혼란을 일으킬 수 있으므로, let과 const를 사용하는 것이 권장됩니다.

### typeof: Symbol
자바스크립트 Symbol 타입은 ES6에서 도입된 원시 데이터 타입(primitive data type) 중 하나입니다. Symbol은 유일한(unique) 값을 나타내는데 사용됩니다. Symbol 값은 항상 유일하며, 다른 어떤 값과도 일치하지 않습니다.

Symbol 값은 다음과 같은 방법으로 생성됩니다.

```javascript

const mySymbol = Symbol();
```
위 예제에서 mySymbol 변수에는 새로운 Symbol 값이 할당됩니다. 이때 생성된 Symbol 값은 유일하며, 다른 Symbol 값과도 일치하지 않습니다.

Symbol 값은 객체의 프로퍼티 키(property key)로 사용될 수 있습니다. 예를 들어 다음과 같은 객체를 만들 수 있습니다.

```javascript

const myObj = {
  [Symbol("key")]: "value",
};
```
위 예제에서 [Symbol("key")]는 Symbol 값이고, 이를 객체의 프로퍼티 키로 사용하고 있습니다. 이렇게 Symbol 값을 사용하면 다른 프로퍼티와 충돌하지 않는 유일한 키를 생성할 수 있습니다.

또한, Symbol 값은 내장 객체에도 사용됩니다. 예를 들어, Symbol.iterator는 이터레이터(iterator)를 생성하는 메서드를 가리키는 Symbol 값입니다. 이러한 내장 Symbol 값은 자바스크립트에서 기본적으로 제공되며, 이를 활용하면 객체의 동작을 제어할 수 있습니다.

Symbol 값은 다른 값과 혼동되지 않는 유일한 값을 나타내는데 사용됩니다. 이를 활용하면 객체의 프로퍼티 키와 같은 곳에서 충돌이 발생하지 않도록 할 수 있으며, 내장 Symbol 값은 객체의 동작을 제어하는 데 사용됩니다.

### typeof: boolean

✔️ `true`와 같이 활용할 수 있는 값 (**`truthy`**)

- 문자열 : 비어 있지 않은 모든 문자열
- 숫자 : 0이 아닌 모든 숫자
- 객체:  모든 객체 (`{}`, `[]` 포함)

✔️ `false`와 같이 활용할 수 있는 값 (**`falsy`**)

- 문자열 : `""` (빈문자열)
- 숫자 : 0, `NaN`
- 객체 : `null`
- `undefined`

<br>
### typeof: NaN
자바스크립트에서 NaN(Not-a-Number)은 숫자가 아님을 나타내는 값입니다. NaN은 다음과 같은 경우에 발생합니다.

수학적으로 유효하지 않은 연산을 수행하는 경우
```javascript

const result = 0 / 0; // NaN
```
숫자가 아닌 값을 숫자로 변환하려는 경우

```javascript

const result = parseInt("hello"); // NaN
```
NaN은 자바스크립트에서 특수한 값으로 취급됩니다. NaN은 어떤 값과도 일치하지 않으며, 자신과도 일치하지 않습니다. 따라서, NaN === NaN의 결과는 false입니다.

NaN은 typeof 연산자를 사용해도 "number" 타입으로 판별됩니다. 이는 NaN이 숫자 타입이긴 하지만, 숫자가 아니기 때문입니다.

NaN 값은 주로 오류 처리에 사용됩니다. 예를 들어, parseInt 함수는 문자열을 정수로 변환하는 함수입니다. 하지만, 인수로 전달된 문자열이 숫자가 아닐 경우 NaN 값을 반환합니다. 따라서, parseInt 함수의 결과가 NaN인지를 확인해 오류 처리를 할 수 있습니다.

```javascript

const input = "hello";
const num = parseInt(input);

if (isNaN(num)) {
  console.log("Input is not a number");
} else {
  console.log("Input is a number");
}
```
위 예제에서 isNaN 함수를 사용해 num 값이 NaN인지를 확인하고 있습니다.

### Math.random()
Math.random()은 자바스크립트에서 난수(random number)를 생성하는 함수입니다. 이 함수는 0 이상 1 미만의 부동소수점(pseudo-random floating-point) 숫자를 반환합니다.

Math.random() 함수는 매번 실행될 때마다 다른 값을 반환하므로, 이를 활용하여 무작위로 선택하는 기능을 구현할 수 있습니다. 예를 들어, 0 이상 10 미만의 정수 중에서 무작위로 선택하고자 한다면, 다음과 같은 코드를 사용할 수 있습니다.

```javascript

var randomInt = Math.floor(Math.random() * 10);
```
위 코드에서 Math.floor() 함수는 주어진 숫자를 내림한 정수를 반환합니다. 따라서 Math.random() * 10은 0 이상 10 미만의 부동소수점 숫자를 반환하며, 이를 Math.floor() 함수로 내림하여 0 이상 9 이하의 정수를 얻을 수 있습니다.

또한, Math.random() 함수를 이용하여 다양한 무작위 알고리즘을 구현할 수 있습니다. 예를 들어, 카드 섞기, 로또 번호 생성, 게임에서의 무작위 이벤트 등에 활용할 수 있습니다.

### parseInt() & parseFloat()
parseInt()와 parseFloat() 함수는 자바스크립트에서 문자열을 정수나 부동소수점 숫자로 변환할 때 사용하는 함수입니다.

parseInt() 함수는 문자열에서 정수를 추출하는 데 사용됩니다. 이 함수는 문자열을 해석하고, 첫 번째 숫자를 발견한 시점에서 나머지 문자를 무시하며, 이후 숫자가 아닌 문자가 나타날 때까지의 숫자만 추출합니다. 예를 들어, 다음 코드에서 parseInt() 함수는 문자열 "42"를 정수 42로 변환합니다.

```javascript

var str = "42";
var num = parseInt(str);
console.log(num); // 42
```
또한, parseInt() 함수는 문자열이 특정 진수로 표현된 경우, 해당 진수의 정수로 변환할 수 있습니다. parseInt() 함수는 두 개의 인수를 받을 수 있으며, 두 번째 인수는 변환할 진수(base)를 지정합니다. 예를 들어, 다음 코드에서 parseInt() 함수는 16진수 문자열 "FF"를 10진수 정수 255로 변환합니다.

```javascript

var hex = "FF";
var num = parseInt(hex, 16);
console.log(num); // 255
```
parseFloat() 함수는 문자열에서 부동소수점 숫자를 추출하는 데 사용됩니다. 이 함수는 parseInt() 함수와 유사하게 문자열을 해석하며, 첫 번째 소수점을 발견한 시점에서 나머지 문자를 무시하고, 이후 숫자가 아닌 문자가 나타날 때까지의 숫자만 추출합니다. 예를 들어, 다음 코드에서 parseFloat() 함수는 문자열 "3.14"를 부동소수점 숫자 3.14로 변환합니다.

```javascript

var str = "3.14";
var num = parseFloat(str);
console.log(num); // 3.14
```
따라서, parseInt() 함수와 parseFloat() 함수는 자바스크립트에서 문자열을 숫자로 변환할 때 사용되며, 각각 정수와 부동소수점 숫자를 추출하는 데 특화되어 있습니다.

### date() - getMonth()에서 실제 월과 1 차이나는 이유

자바스크립트의 Date() 객체에서 월(month)을 나타내는 메서드인 getMonth()는 0부터 시작하여 11까지의 값을 반환합니다. 즉, getMonth()에서 반환하는 값은 실제 월에서 1을 뺀 값과 같습니다.

이러한 구현은 초기 자바스크립트가 만들어진 시점에서의 표준과 호환성을 유지하기 위해서입니다. 자바스크립트가 처음 만들어질 때, C 언어와의 호환성을 유지하기 위해 Date() 객체에서 월을 0부터 시작하는 형태로 구현되었습니다. 이후에도 이러한 구현이 계속 사용되어 왔습니다.

따라서, Date() 객체에서 월을 나타내는 메서드를 사용할 때는 반환값에서 1을 더하여 실제 월을 구해야 합니다. 예를 들어, 다음 코드에서 date.getMonth() 메서드는 2를 반환합니다. 이는 실제 월인 3월에서 1을 뺀 값과 같습니다.

```javascript

var date = new Date('2023-03-01');
var month = date.getMonth() + 1;
console.log(month); // 3
```

### 'use strict'
맨 위에 'use strict'; 선언하고 사용하기
vanilla JS로 할 때 유용
ECMAScript5에 선언된 것으로, 비상식적인 코드가 허용되지 않음   
유연한 JS에서 필요한 선언, strict mode 활성화됨   
상식적인 범위 안에서 js 사용 가능하며, 엔진이 더 효율적으로 js 실행함

### 바닐라 JS
- 바닐라 자바스크립트(Vanilla JavaScript)는 브라우저 상에서 실행되는 자바스크립트 코드를 의미합니다. 바닐라 자바스크립트는 어떠한 프레임워크나 라이브러리를 사용하지 않고, 순수 자바스크립트 코드만으로 웹 페이지를 제어하는 방법을 말합니다.   

- 최근 몇 년간 프론트엔드 프레임워크의 대중화로 인해, 리액트(React), 앵귤러(Angular), 뷰(Vue)와 같은 프레임워크와 라이브러리들이 대세입니다. 하지만, 바닐라 자바스크립트는 이러한 프레임워크나 라이브러리 없이도 웹 페이지를 구현할 수 있는 가장 기본적인 방법이며, 프레임워크나 라이브러리에 의존하지 않고 웹 페이지를 만들 수 있는 장점이 있습니다.   

- 바닐라 자바스크립트를 잘 다루는 것은, 자바스크립트를 이해하고 웹 개발의 기본을 숙지하는 데 매우 중요합니다.   

### JSON
JSON은 JavaScript Object Notation의 약자로, 경량화된 데이터 교환 형식입니다. 이 데이터 교환 형식은 속성-값 쌍 또는 키-값 쌍을 사용하여 데이터를 표현합니다.

JSON은 인간이 쉽게 읽고 쓸 수 있으며, 기계가 쉽게 분석하고 생성할 수 있는 형식입니다. 또한 다른 언어와 플랫폼 간에 데이터를 교환하기에 적합합니다.

JSON은 자바스크립트의 객체 표현 방식을 기반으로 하지만, 다른 언어들도 JSON을 지원하며, 이를 통해 다른 프로그래밍 언어와 상호 작용할 수 있습니다.

JSON 형식은 중괄호({})로 객체를, 대괄호([])로 배열을 표현합니다. 객체는 키-값 쌍으로 표현되며, 키와 값은 콜론(:)으로 구분됩니다. 여러 개의 속성-값 쌍은 쉼표(,)로 구분됩니다. 예를 들어, 다음은 JSON 객체의 예입니다.
```json

{
   "name": "John",
   "age": 30,
   "city": "New York"
}
```
배열은 값의 목록으로 표현됩니다. 배열의 값은 쉼표로 구분됩니다. 예를 들어, 다음은 JSON 배열의 예입니다.

```css

[   "apple",   "banana",   "orange"]
```
JSON은 웹 애플리케이션에서 데이터를 교환하기 위한 표준 형식 중 하나이며, RESTful API와 같은 웹 서비스에서도 널리 사용됩니다.

### 0302
e는 'keydown'이라는 event 객체를 의미한다. 한 함수 안에 (event, function(e))라고 되어있으면, 앞에가 인자다. 즉, e는 앞에서 지정한 event.
